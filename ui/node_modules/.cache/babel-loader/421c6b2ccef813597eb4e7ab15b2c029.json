{"ast":null,"code":"\"use strict\";\n\nvar format = require(\"format-util\");\n\nvar slice = Array.prototype.slice;\nvar protectedProperties = [\"name\", \"message\", \"stack\"];\nvar errorPrototypeProperties = [\"name\", \"message\", \"description\", \"number\", \"code\", \"fileName\", \"lineNumber\", \"columnNumber\", \"sourceURL\", \"line\", \"column\", \"stack\"];\nmodule.exports = create(Error);\nmodule.exports.error = create(Error);\nmodule.exports.eval = create(EvalError);\nmodule.exports.range = create(RangeError);\nmodule.exports.reference = create(ReferenceError);\nmodule.exports.syntax = create(SyntaxError);\nmodule.exports.type = create(TypeError);\nmodule.exports.uri = create(URIError);\nmodule.exports.formatter = format;\n/**\n * Creates a new {@link ono} function that creates the given Error class.\n *\n * @param {Class} Klass - The Error subclass to create\n * @returns {ono}\n */\n\nfunction create(Klass) {\n  /**\n   * @param {Error}   [err]     - The original error, if any\n   * @param {object}  [props]   - An object whose properties will be added to the error object\n   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders\n   * @param {...*}    [params]  - Parameters that map to the `message` placeholders\n   * @returns {Error}\n   */\n  return function onoFactory(err, props, message, params) {\n    // eslint-disable-line no-unused-vars\n    var formatArgs = [];\n    var formattedMessage = \"\"; // Determine which arguments were actually specified\n\n    if (typeof err === \"string\") {\n      formatArgs = slice.call(arguments);\n      err = props = undefined;\n    } else if (typeof props === \"string\") {\n      formatArgs = slice.call(arguments, 1);\n      props = undefined;\n    } else if (typeof message === \"string\") {\n      formatArgs = slice.call(arguments, 2);\n    } // If there are any format arguments, then format the error message\n\n\n    if (formatArgs.length > 0) {\n      formattedMessage = module.exports.formatter.apply(null, formatArgs);\n    }\n\n    if (err && err.message) {\n      // The inner-error's message will be added to the new message\n      formattedMessage += (formattedMessage ? \" \\n\" : \"\") + err.message;\n    } // Create the new error\n    // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace\n\n\n    var newError = new Klass(formattedMessage); // Extend the new error with the additional properties\n\n    extendError(newError, err); // Copy properties of the original error\n\n    extendToJSON(newError); // Replace the original toJSON method\n\n    extend(newError, props); // Copy custom properties, possibly including a custom toJSON method\n\n    return newError;\n  };\n}\n/**\n * Extends the targetError with the properties of the source error.\n *\n * @param {Error}   targetError - The error object to extend\n * @param {?Error}  sourceError - The source error object, if any\n */\n\n\nfunction extendError(targetError, sourceError) {\n  extendStack(targetError, sourceError);\n  extend(targetError, sourceError);\n}\n/**\n * JavaScript engines differ in how errors are serialized to JSON - especially when it comes\n * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS\n * outputs every property of the error.\n */\n\n\nfunction extendToJSON(error) {\n  error.toJSON = errorToJSON; // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method\n\n  error.inspect = errorToString;\n}\n/**\n * Extends the target object with the properties of the source object.\n *\n * @param {object}  target - The object to extend\n * @param {?source} source - The object whose properties are copied\n */\n\n\nfunction extend(target, source) {\n  if (source && typeof source === \"object\") {\n    var keys = Object.keys(source);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // Don't copy \"protected\" properties, since they have special meaning/behavior\n      // and are set by the onoFactory function\n\n      if (protectedProperties.indexOf(key) >= 0) {\n        continue;\n      }\n\n      try {\n        target[key] = source[key];\n      } catch (e) {// This property is read-only, so it can't be copied\n      }\n    }\n  }\n}\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n *\n * @returns {object}\n */\n\n\nfunction errorToJSON() {\n  var json = {}; // Get all the properties of this error\n\n  var keys = Object.keys(this); // Also include properties from the Error prototype\n\n  keys = keys.concat(errorPrototypeProperties);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this[key];\n    var type = typeof value;\n\n    if (type !== \"undefined\" && type !== \"function\") {\n      json[key] = value;\n    }\n  }\n\n  return json;\n}\n/**\n * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.\n *\n * @returns {string}\n */\n\n\nfunction errorToString() {\n  return JSON.stringify(this, null, 2).replace(/\\\\n/g, \"\\n\");\n}\n/**\n * Extend the error stack to include its cause\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\n\n\nfunction extendStack(targetError, sourceError) {\n  if (hasLazyStack(targetError)) {\n    if (sourceError) {\n      lazyJoinStacks(targetError, sourceError);\n    } else {\n      lazyPopStack(targetError);\n    }\n  } else {\n    if (sourceError) {\n      targetError.stack = joinStacks(targetError.stack, sourceError.stack);\n    } else {\n      targetError.stack = popStack(targetError.stack);\n    }\n  }\n}\n/**\n * Appends the original {@link Error#stack} property to the new Error's stack.\n *\n * @param {string} newStack\n * @param {string} originalStack\n * @returns {string}\n */\n\n\nfunction joinStacks(newStack, originalStack) {\n  newStack = popStack(newStack);\n\n  if (newStack && originalStack) {\n    return newStack + \"\\n\\n\" + originalStack;\n  } else {\n    return newStack || originalStack;\n  }\n}\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n *\n * @param {string} stack\n * @returns {string}\n */\n\n\nfunction popStack(stack) {\n  if (stack) {\n    var lines = stack.split(\"\\n\");\n\n    if (lines.length < 2) {\n      // The stack only has one line, so there's nothing we can remove\n      return stack;\n    } // Find the `onoFactory` call in the stack, and remove it\n\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n\n      if (line.indexOf(\"onoFactory\") >= 0) {\n        lines.splice(i, 1);\n        return lines.join(\"\\n\");\n      }\n    } // If we get here, then the stack doesn't contain a call to `onoFactory`.\n    // This may be due to minification or some optimization of the JS engine.\n    // So just return the stack as-is.\n\n\n    return stack;\n  }\n}\n/**\n * Does a one-time determination of whether this JavaScript engine\n * supports lazy `Error.stack` properties.\n */\n\n\nvar supportsLazyStack = function () {\n  return !!( // ES5 property descriptors must be supported\n  Object.getOwnPropertyDescriptor && Object.defineProperty && ( // Chrome on Android doesn't support lazy stacks :(\n  typeof navigator === \"undefined\" || !/Android/.test(navigator.userAgent)));\n}();\n/**\n * Does this error have a lazy stack property?\n *\n * @param {Error} err\n * @returns {boolean}\n */\n\n\nfunction hasLazyStack(err) {\n  if (!supportsLazyStack) {\n    return false;\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(err, \"stack\");\n\n  if (!descriptor) {\n    return false;\n  }\n\n  return typeof descriptor.get === \"function\";\n}\n/**\n * Calls {@link joinStacks} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\n\n\nfunction lazyJoinStacks(targetError, sourceError) {\n  var targetStack = Object.getOwnPropertyDescriptor(targetError, \"stack\");\n  Object.defineProperty(targetError, \"stack\", {\n    get: function get() {\n      return joinStacks(targetStack.get.apply(targetError), sourceError.stack);\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n/**\n * Calls {@link popStack} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} error\n */\n\n\nfunction lazyPopStack(error) {\n  var targetStack = Object.getOwnPropertyDescriptor(error, \"stack\");\n  Object.defineProperty(error, \"stack\", {\n    get: function get() {\n      return popStack(targetStack.get.apply(error));\n    },\n    enumerable: false,\n    configurable: true\n  });\n}","map":null,"metadata":{},"sourceType":"script"}