{"ast":null,"code":"/*\n   Modifications for better node.js integration:\n    Copyright 2014 Brian White. All rights reserved.\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n*/\n\n/*\n   Original source code:\n    Copyright 2014 Joshua Bell\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n/**\n * @param {number} n The numerator.\n * @param {number} d The denominator.\n * @return {number} The result of the integer division of n by d.\n */\n\n\nfunction div(n, d) {\n  return Math.floor(n / d);\n} //\n// Implementation of Encoding specification\n// http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html\n//\n//\n// 3. Terminology\n//\n//\n// 4. Encodings\n//\n\n/** @const */\n\n\nvar EOF_byte = -1;\n/** @const */\n\nvar EOF_code_point = -1;\n/**\n * @constructor\n * @param {Buffer} bytes Array of bytes that provide the stream.\n */\n\nfunction ByteInputStream(bytes) {\n  /** @type {number} */\n  var pos = 0;\n  /**\n   * @this {ByteInputStream}\n   * @return {number} Get the next byte from the stream.\n   */\n\n  this.get = function () {\n    return pos >= bytes.length ? EOF_byte : Number(bytes[pos]);\n  };\n  /** @param {number} n Number (positive or negative) by which to\n   *      offset the byte pointer. */\n\n\n  this.offset = function (n) {\n    pos += n;\n\n    if (pos < 0) {\n      throw new Error('Seeking past start of the buffer');\n    }\n\n    if (pos > bytes.length) {\n      throw new Error('Seeking past EOF');\n    }\n  };\n  /**\n   * @param {Array.<number>} test Array of bytes to compare against.\n   * @return {boolean} True if the start of the stream matches the test\n   *     bytes.\n   */\n\n\n  this.match = function (test) {\n    if (test.length > pos + bytes.length) {\n      return false;\n    }\n\n    var i;\n\n    for (i = 0; i < test.length; i += 1) {\n      if (Number(bytes[pos + i]) !== test[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n/**\n * @constructor\n * @param {Array.<number>} bytes The array to write bytes into.\n */\n\n\nfunction ByteOutputStream(bytes) {\n  /** @type {number} */\n  var pos = 0;\n  /**\n   * @param {...number} var_args The byte or bytes to emit into the stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.emit = function (var_args) {\n    /** @type {number} */\n    var last = EOF_byte;\n    var i;\n\n    for (i = 0; i < arguments.length; ++i) {\n      last = Number(arguments[i]);\n      bytes[pos++] = last;\n    }\n\n    return last;\n  };\n}\n/**\n * @constructor\n * @param {string} string The source of code units for the stream.\n */\n\n\nfunction CodePointInputStream(string) {\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    /** @type {Array.<number>} */\n    var cps = []; // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString\n\n    var i = 0,\n        n = string.length;\n\n    while (i < string.length) {\n      var c = string.charCodeAt(i);\n\n      if (!inRange(c, 0xD800, 0xDFFF)) {\n        cps.push(c);\n      } else if (inRange(c, 0xDC00, 0xDFFF)) {\n        cps.push(0xFFFD);\n      } else {\n        // (inRange(cu, 0xD800, 0xDBFF))\n        if (i === n - 1) {\n          cps.push(0xFFFD);\n        } else {\n          var d = string.charCodeAt(i + 1);\n\n          if (inRange(d, 0xDC00, 0xDFFF)) {\n            var a = c & 0x3FF;\n            var b = d & 0x3FF;\n            i += 1;\n            cps.push(0x10000 + (a << 10) + b);\n          } else {\n            cps.push(0xFFFD);\n          }\n        }\n      }\n\n      i += 1;\n    }\n\n    return cps;\n  }\n  /** @type {number} */\n\n\n  var pos = 0;\n  /** @type {Array.<number>} */\n\n  var cps = stringToCodePoints(string);\n  /** @param {number} n The number of bytes (positive or negative)\n   *      to advance the code point pointer by.*/\n\n  this.offset = function (n) {\n    pos += n;\n\n    if (pos < 0) {\n      throw new Error('Seeking past start of the buffer');\n    }\n\n    if (pos > cps.length) {\n      throw new Error('Seeking past EOF');\n    }\n  };\n  /** @return {number} Get the next code point from the stream. */\n\n\n  this.get = function () {\n    if (pos >= cps.length) {\n      return EOF_code_point;\n    }\n\n    return cps[pos];\n  };\n}\n/**\n * @constructor\n */\n\n\nfunction CodePointOutputStream() {\n  /** @type {string} */\n  var string = '';\n  /** @return {string} The accumulated string. */\n\n  this.string = function () {\n    return string;\n  };\n  /** @param {number} c The code point to encode into the stream. */\n\n\n  this.emit = function (c) {\n    if (c <= 0xFFFF) {\n      string += String.fromCharCode(c);\n    } else {\n      c -= 0x10000;\n      string += String.fromCharCode(0xD800 + (c >> 10 & 0x3ff));\n      string += String.fromCharCode(0xDC00 + (c & 0x3ff));\n    }\n  };\n}\n/**\n * @constructor\n * @param {string} message Description of the error.\n */\n\n\nfunction EncodingError(message) {\n  this.name = 'EncodingError';\n  this.message = message;\n  this.code = 0;\n}\n\nEncodingError.prototype = Error.prototype;\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\n\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal) {\n    throw new EncodingError('Decoder error');\n  }\n\n  return opt_code_point || 0xFFFD;\n}\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\n\n\nfunction encoderError(code_point) {\n  throw new EncodingError('The code point ' + code_point + ' could not be encoded.');\n}\n/**\n * @param {string} label The encoding label.\n * @return {?{name:string,labels:Array.<string>}}\n */\n\n\nfunction getEncoding(label) {\n  label = String(label).trim().toLowerCase();\n\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n\n  return null;\n}\n/** @type {Array.<{encodings: Array.<{name:string,labels:Array.<string>}>,\n *      heading: string}>} */\n\n\nvar encodings = [{\n  \"encodings\": [{\n    \"labels\": [\"unicode-1-1-utf-8\", \"utf-8\", \"utf8\"],\n    \"name\": \"utf-8\"\n  }],\n  \"heading\": \"The Encoding\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"864\", \"cp864\", \"csibm864\", \"ibm864\"],\n    \"name\": \"ibm864\"\n  }, {\n    \"labels\": [\"866\", \"cp866\", \"csibm866\", \"ibm866\"],\n    \"name\": \"ibm866\"\n  }, {\n    \"labels\": [\"csisolatin2\", \"iso-8859-2\", \"iso-ir-101\", \"iso8859-2\", \"iso88592\", \"iso_8859-2\", \"iso_8859-2:1987\", \"l2\", \"latin2\"],\n    \"name\": \"iso-8859-2\"\n  }, {\n    \"labels\": [\"csisolatin3\", \"iso-8859-3\", \"iso-ir-109\", \"iso8859-3\", \"iso88593\", \"iso_8859-3\", \"iso_8859-3:1988\", \"l3\", \"latin3\"],\n    \"name\": \"iso-8859-3\"\n  }, {\n    \"labels\": [\"csisolatin4\", \"iso-8859-4\", \"iso-ir-110\", \"iso8859-4\", \"iso88594\", \"iso_8859-4\", \"iso_8859-4:1988\", \"l4\", \"latin4\"],\n    \"name\": \"iso-8859-4\"\n  }, {\n    \"labels\": [\"csisolatincyrillic\", \"cyrillic\", \"iso-8859-5\", \"iso-ir-144\", \"iso8859-5\", \"iso88595\", \"iso_8859-5\", \"iso_8859-5:1988\"],\n    \"name\": \"iso-8859-5\"\n  }, {\n    \"labels\": [\"arabic\", \"asmo-708\", \"csiso88596e\", \"csiso88596i\", \"csisolatinarabic\", \"ecma-114\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-ir-127\", \"iso8859-6\", \"iso88596\", \"iso_8859-6\", \"iso_8859-6:1987\"],\n    \"name\": \"iso-8859-6\"\n  }, {\n    \"labels\": [\"csisolatingreek\", \"ecma-118\", \"elot_928\", \"greek\", \"greek8\", \"iso-8859-7\", \"iso-ir-126\", \"iso8859-7\", \"iso88597\", \"iso_8859-7\", \"iso_8859-7:1987\", \"sun_eu_greek\"],\n    \"name\": \"iso-8859-7\"\n  }, {\n    \"labels\": [\"csiso88598e\", \"csisolatinhebrew\", \"hebrew\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-ir-138\", \"iso8859-8\", \"iso88598\", \"iso_8859-8\", \"iso_8859-8:1988\", \"visual\"],\n    \"name\": \"iso-8859-8\"\n  }, {\n    \"labels\": [\"csiso88598i\", \"iso-8859-8-i\", \"logical\"],\n    \"name\": \"iso-8859-8-i\"\n  }, {\n    \"labels\": [\"csisolatin6\", \"iso-8859-10\", \"iso-ir-157\", \"iso8859-10\", \"iso885910\", \"l6\", \"latin6\"],\n    \"name\": \"iso-8859-10\"\n  }, {\n    \"labels\": [\"iso-8859-13\", \"iso8859-13\", \"iso885913\"],\n    \"name\": \"iso-8859-13\"\n  }, {\n    \"labels\": [\"iso-8859-14\", \"iso8859-14\", \"iso885914\"],\n    \"name\": \"iso-8859-14\"\n  }, {\n    \"labels\": [\"csisolatin9\", \"iso-8859-15\", \"iso8859-15\", \"iso885915\", \"iso_8859-15\", \"l9\"],\n    \"name\": \"iso-8859-15\"\n  }, {\n    \"labels\": [\"iso-8859-16\"],\n    \"name\": \"iso-8859-16\"\n  }, {\n    \"labels\": [\"cskoi8r\", \"koi\", \"koi8\", \"koi8-r\", \"koi8_r\"],\n    \"name\": \"koi8-r\"\n  }, {\n    \"labels\": [\"koi8-u\"],\n    \"name\": \"koi8-u\"\n  }, {\n    \"labels\": [\"csmacintosh\", \"mac\", \"macintosh\", \"x-mac-roman\"],\n    \"name\": \"macintosh\"\n  }, {\n    \"labels\": [\"dos-874\", \"iso-8859-11\", \"iso8859-11\", \"iso885911\", \"tis-620\", \"windows-874\"],\n    \"name\": \"windows-874\"\n  }, {\n    \"labels\": [\"cp1250\", \"windows-1250\", \"x-cp1250\"],\n    \"name\": \"windows-1250\"\n  }, {\n    \"labels\": [\"cp1251\", \"windows-1251\", \"x-cp1251\"],\n    \"name\": \"windows-1251\"\n  }, {\n    \"labels\": [\"ansi_x3.4-1968\", \"ascii\", \"cp1252\", \"cp819\", \"csisolatin1\", \"ibm819\", \"iso-8859-1\", \"iso-ir-100\", \"iso8859-1\", \"iso88591\", \"iso_8859-1\", \"iso_8859-1:1987\", \"l1\", \"latin1\", \"us-ascii\", \"windows-1252\", \"x-cp1252\"],\n    \"name\": \"windows-1252\"\n  }, {\n    \"labels\": [\"cp1253\", \"windows-1253\", \"x-cp1253\"],\n    \"name\": \"windows-1253\"\n  }, {\n    \"labels\": [\"cp1254\", \"csisolatin5\", \"iso-8859-9\", \"iso-ir-148\", \"iso8859-9\", \"iso88599\", \"iso_8859-9\", \"iso_8859-9:1989\", \"l5\", \"latin5\", \"windows-1254\", \"x-cp1254\"],\n    \"name\": \"windows-1254\"\n  }, {\n    \"labels\": [\"cp1255\", \"windows-1255\", \"x-cp1255\"],\n    \"name\": \"windows-1255\"\n  }, {\n    \"labels\": [\"cp1256\", \"windows-1256\", \"x-cp1256\"],\n    \"name\": \"windows-1256\"\n  }, {\n    \"labels\": [\"cp1257\", \"windows-1257\", \"x-cp1257\"],\n    \"name\": \"windows-1257\"\n  }, {\n    \"labels\": [\"cp1258\", \"windows-1258\", \"x-cp1258\"],\n    \"name\": \"windows-1258\"\n  }, {\n    \"labels\": [\"x-mac-cyrillic\", \"x-mac-ukrainian\"],\n    \"name\": \"x-mac-cyrillic\"\n  }],\n  \"heading\": \"Legacy single-byte encodings\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"chinese\", \"csgb2312\", \"csiso58gb231280\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"iso-ir-58\", \"x-gbk\"],\n    \"name\": \"gbk\"\n  }, {\n    \"labels\": [\"gb18030\"],\n    \"name\": \"gb18030\"\n  }, {\n    \"labels\": [\"hz-gb-2312\"],\n    \"name\": \"hz-gb-2312\"\n  }],\n  \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"big5\", \"big5-hkscs\", \"cn-big5\", \"csbig5\", \"x-x-big5\"],\n    \"name\": \"big5\"\n  }],\n  \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"cseucpkdfmtjapanese\", \"euc-jp\", \"x-euc-jp\"],\n    \"name\": \"euc-jp\"\n  }, {\n    \"labels\": [\"csiso2022jp\", \"iso-2022-jp\"],\n    \"name\": \"iso-2022-jp\"\n  }, {\n    \"labels\": [\"csshiftjis\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"windows-31j\", \"x-sjis\"],\n    \"name\": \"shift_jis\"\n  }],\n  \"heading\": \"Legacy multi-byte Japanese encodings\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"cseuckr\", \"csksc56011987\", \"euc-kr\", \"iso-ir-149\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"windows-949\"],\n    \"name\": \"euc-kr\"\n  }],\n  \"heading\": \"Legacy multi-byte Korean encodings\"\n}, {\n  \"encodings\": [{\n    \"labels\": [\"csiso2022kr\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-kr\"],\n    \"name\": \"replacement\"\n  }, {\n    \"labels\": [\"utf-16be\"],\n    \"name\": \"utf-16be\"\n  }, {\n    \"labels\": [\"utf-16\", \"utf-16le\"],\n    \"name\": \"utf-16le\"\n  }, {\n    \"labels\": [\"x-user-defined\"],\n    \"name\": \"x-user-defined\"\n  }],\n  \"heading\": \"Legacy miscellaneous encodings\"\n}];\nvar name_to_encoding = {};\nvar label_to_encoding = {};\nencodings.forEach(function (category) {\n  category.encodings.forEach(function (encoding) {\n    name_to_encoding[encoding.name] = encoding;\n    encoding.labels.forEach(function (label) {\n      label_to_encoding[label] = encoding;\n    });\n  });\n}); //\n// 5. Indexes\n//\n\n/**\n * @param {number} pointer The |pointer| to search for.\n * @param {Array.<?number>|undefined} index The |index| to search within.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in |index|.\n */\n\nfunction indexCodePointFor(pointer, index) {\n  if (!index) return null;\n  return index[pointer] || null;\n}\n/**\n * @param {number} code_point The |code point| to search for.\n * @param {Array.<?number>} index The |index| to search within.\n * @return {?number} The first pointer corresponding to |code point| in\n *     |index|, or null if |code point| is not in |index|.\n */\n\n\nfunction indexPointerFor(code_point, index) {\n  var pointer = index.indexOf(code_point);\n  return pointer === -1 ? null : pointer;\n}\n/** @type {Object.<string, (Array.<number>|Array.<Array.<number>>)>} */\n\n\nvar indexes = require('./encoding-indexes');\n/**\n * @param {number} pointer The |pointer| to search for in the gb18030 index.\n * @return {?number} The code point corresponding to |pointer| in |index|,\n *     or null if |code point| is not in the gb18030 index.\n */\n\n\nfunction indexGB18030CodePointFor(pointer) {\n  if (pointer > 39419 && pointer < 189000 || pointer > 1237575) {\n    return null;\n  }\n\n  var\n  /** @type {number} */\n  offset = 0,\n\n  /** @type {number} */\n  code_point_offset = 0,\n\n  /** @type {Array.<Array.<number>>} */\n  idx = indexes['gb18030'];\n  var i;\n\n  for (i = 0; i < idx.length; ++i) {\n    var entry = idx[i];\n\n    if (entry[0] <= pointer) {\n      offset = entry[0];\n      code_point_offset = entry[1];\n    } else {\n      break;\n    }\n  }\n\n  return code_point_offset + pointer - offset;\n}\n/**\n * @param {number} code_point The |code point| to locate in the gb18030 index.\n * @return {number} The first pointer corresponding to |code point| in the\n *     gb18030 index.\n */\n\n\nfunction indexGB18030PointerFor(code_point) {\n  var\n  /** @type {number} */\n  offset = 0,\n\n  /** @type {number} */\n  pointer_offset = 0,\n\n  /** @type {Array.<Array.<number>>} */\n  idx = indexes['gb18030'];\n  var i;\n\n  for (i = 0; i < idx.length; ++i) {\n    var entry = idx[i];\n\n    if (entry[1] <= code_point) {\n      offset = entry[1];\n      pointer_offset = entry[0];\n    } else {\n      break;\n    }\n  }\n\n  return pointer_offset + code_point - offset;\n} //\n// 7. API\n//\n\n/** @const */\n\n\nvar DEFAULT_ENCODING = 'utf-8'; // 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} opt_encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {{fatal: boolean}=} options\n */\n\nfunction TextDecoder(opt_encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(opt_encoding, options);\n  }\n\n  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;\n  options = Object(options);\n  /** @private */\n\n  this._encoding = getEncoding(opt_encoding);\n  if (this._encoding === null || this._encoding.name === 'replacement') throw new TypeError('Unknown encoding: ' + opt_encoding);\n  /** @private @type {boolean} */\n\n  this._streaming = false;\n  /** @private @type {boolean} */\n\n  this._BOMseen = false;\n  /** @private */\n\n  this._decoder = null;\n  /** @private @type {{fatal: boolean}=} */\n\n  this._options = {\n    fatal: Boolean(options.fatal)\n  };\n\n  if (Object.defineProperty) {\n    Object.defineProperty(this, 'encoding', {\n      get: function get() {\n        return this._encoding.name;\n      }\n    });\n  } else {\n    this.encoding = this._encoding.name;\n  }\n\n  return this;\n} // TODO: Issue if input byte stream is offset by decoder\n// TODO: BOM detection will not work if stream header spans multiple calls\n// (last N bytes of previous stream may need to be retained?)\n\n\nTextDecoder.prototype = {\n  /**\n   * @param {Buffer=} bytes The buffer of bytes to decode.\n   * @param {{stream: boolean}=} options\n   */\n  decode: function decode(bytes, options) {\n    options = Object(options);\n\n    if (!this._streaming) {\n      this._decoder = this._encoding.getDecoder(this._options);\n      this._BOMseen = false;\n    }\n\n    this._streaming = Boolean(options.stream);\n    var input_stream = new ByteInputStream(bytes);\n    var output_stream = new CodePointOutputStream();\n    /** @type {number} */\n\n    var code_point;\n\n    while (input_stream.get() !== EOF_byte) {\n      code_point = this._decoder.decode(input_stream);\n\n      if (code_point !== null && code_point !== EOF_code_point) {\n        output_stream.emit(code_point);\n      }\n    }\n\n    if (!this._streaming) {\n      do {\n        code_point = this._decoder.decode(input_stream);\n\n        if (code_point !== null && code_point !== EOF_code_point) {\n          output_stream.emit(code_point);\n        }\n      } while (code_point !== EOF_code_point && input_stream.get() != EOF_byte);\n\n      this._decoder = null;\n    }\n\n    var result = output_stream.string();\n\n    if (!this._BOMseen && result.length) {\n      this._BOMseen = true;\n\n      if (UTFs.indexOf(this.encoding) !== -1 && result.charCodeAt(0) === 0xFEFF) {\n        result = result.substring(1);\n      }\n    }\n\n    return result;\n  }\n};\nvar UTFs = ['utf-8', 'utf-16le', 'utf-16be']; // 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} opt_encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {{fatal: boolean}=} options\n */\n\nfunction TextEncoder(opt_encoding, options) {\n  if (!(this instanceof TextEncoder)) {\n    return new TextEncoder(opt_encoding, options);\n  }\n\n  opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;\n  options = Object(options);\n  /** @private */\n\n  this._encoding = getEncoding(opt_encoding);\n  if (this._encoding === null || this._encoding.name !== 'utf-8' && this._encoding.name !== 'utf-16le' && this._encoding.name !== 'utf-16be') throw new TypeError('Unknown encoding: ' + opt_encoding);\n  /** @private @type {boolean} */\n\n  this._streaming = false;\n  /** @private */\n\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}=} */\n\n  this._options = {\n    fatal: Boolean(options.fatal)\n  };\n\n  if (Object.defineProperty) {\n    Object.defineProperty(this, 'encoding', {\n      get: function get() {\n        return this._encoding.name;\n      }\n    });\n  } else {\n    this.encoding = this._encoding.name;\n  }\n\n  return this;\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {{stream: boolean}=} options\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = Object(options); // TODO: any options?\n\n    if (!this._streaming) {\n      this._encoder = this._encoding.getEncoder(this._options);\n    }\n\n    this._streaming = Boolean(options.stream);\n    var bytes = [];\n    var output_stream = new ByteOutputStream(bytes);\n    var input_stream = new CodePointInputStream(opt_string);\n\n    while (input_stream.get() !== EOF_code_point) {\n      this._encoder.encode(output_stream, input_stream);\n    }\n\n    if (!this._streaming) {\n      /** @type {number} */\n      var last_byte;\n\n      do {\n        last_byte = this._encoder.encode(output_stream, input_stream);\n      } while (last_byte !== EOF_byte);\n\n      this._encoder = null;\n    }\n\n    return new Buffer(bytes);\n  }\n}; //\n// 8. The encoding\n//\n// 8.1 utf-8\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  utf8_code_point = 0,\n\n  /** @type {number} */\n  utf8_bytes_needed = 0,\n\n  /** @type {number} */\n  utf8_bytes_seen = 0,\n\n  /** @type {number} */\n  utf8_lower_boundary = 0;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte) {\n      if (utf8_bytes_needed !== 0) {\n        return decoderError(fatal);\n      }\n\n      return EOF_code_point;\n    }\n\n    byte_pointer.offset(1);\n\n    if (utf8_bytes_needed === 0) {\n      if (inRange(bite, 0x00, 0x7F)) {\n        return bite;\n      }\n\n      if (inRange(bite, 0xC2, 0xDF)) {\n        utf8_bytes_needed = 1;\n        utf8_lower_boundary = 0x80;\n        utf8_code_point = bite - 0xC0;\n      } else if (inRange(bite, 0xE0, 0xEF)) {\n        utf8_bytes_needed = 2;\n        utf8_lower_boundary = 0x800;\n        utf8_code_point = bite - 0xE0;\n      } else if (inRange(bite, 0xF0, 0xF4)) {\n        utf8_bytes_needed = 3;\n        utf8_lower_boundary = 0x10000;\n        utf8_code_point = bite - 0xF0;\n      } else {\n        return decoderError(fatal);\n      }\n\n      utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);\n      return null;\n    }\n\n    if (!inRange(bite, 0x80, 0xBF)) {\n      utf8_code_point = 0;\n      utf8_bytes_needed = 0;\n      utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0;\n      byte_pointer.offset(-1);\n      return decoderError(fatal);\n    }\n\n    utf8_bytes_seen += 1;\n    utf8_code_point = utf8_code_point + (bite - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);\n\n    if (utf8_bytes_seen !== utf8_bytes_needed) {\n      return null;\n    }\n\n    var code_point = utf8_code_point;\n    var lower_boundary = utf8_lower_boundary;\n    utf8_code_point = 0;\n    utf8_bytes_needed = 0;\n    utf8_bytes_seen = 0;\n    utf8_lower_boundary = 0;\n\n    if (inRange(code_point, lower_boundary, 0x10FFFF) && !inRange(code_point, 0xD800, 0xDFFF)) {\n      return code_point;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    /** @type {number} */\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0xD800, 0xDFFF)) {\n      return encoderError(code_point);\n    }\n\n    if (inRange(code_point, 0x0000, 0x007f)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    var count, offset;\n\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    } else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    } else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    var result = output_byte_stream.emit(div(code_point, Math.pow(64, count)) + offset);\n\n    while (count > 0) {\n      var temp = div(code_point, Math.pow(64, count - 1));\n      result = output_byte_stream.emit(0x80 + temp % 64);\n      count -= 1;\n    }\n\n    return result;\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-8'].getEncoder = function (options) {\n  return new UTF8Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-8'].getDecoder = function (options) {\n  return new UTF8Decoder(options);\n}; //\n// 9. Legacy single-byte encodings\n//\n\n/**\n * @constructor\n * @param {Array.<number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction SingleByteDecoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte) {\n      return EOF_code_point;\n    }\n\n    byte_pointer.offset(1);\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    var code_point = index[bite - 0x80];\n\n    if (code_point === null) {\n      return decoderError(fatal);\n    }\n\n    return code_point;\n  };\n}\n/**\n * @constructor\n * @param {Array.<?number>} index The encoding index.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction SingleByteEncoder(index, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    var pointer = indexPointerFor(code_point, index);\n\n    if (pointer === null) {\n      encoderError(code_point);\n    }\n\n    return output_byte_stream.emit(pointer + 0x80);\n  };\n}\n\n(function () {\n  encodings.forEach(function (category) {\n    if (category.heading !== 'Legacy single-byte encodings') return;\n    category.encodings.forEach(function (encoding) {\n      var idx = indexes[encoding.name];\n      /** @param {{fatal: boolean}} options */\n\n      encoding.getDecoder = function (options) {\n        return new SingleByteDecoder(idx, options);\n      };\n      /** @param {{fatal: boolean}} options */\n\n\n      encoding.getEncoder = function (options) {\n        return new SingleByteEncoder(idx, options);\n      };\n    });\n  });\n})(); //\n// 10. Legacy multi-byte Chinese (simplified) encodings\n//\n// 9.1 gbk\n\n/**\n * @constructor\n * @param {boolean} gb18030 True if decoding gb18030, false otherwise.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction GBKDecoder(gb18030, options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  gbk_first = 0x00,\n\n  /** @type {number} */\n  gbk_second = 0x00,\n\n  /** @type {number} */\n  gbk_third = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && gbk_first === 0x00 && gbk_second === 0x00 && gbk_third === 0x00) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && (gbk_first !== 0x00 || gbk_second !== 0x00 || gbk_third !== 0x00)) {\n      gbk_first = 0x00;\n      gbk_second = 0x00;\n      gbk_third = 0x00;\n      decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n    var code_point;\n\n    if (gbk_third !== 0x00) {\n      code_point = null;\n\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030CodePointFor((((gbk_first - 0x81) * 10 + (gbk_second - 0x30)) * 126 + (gbk_third - 0x81)) * 10 + bite - 0x30);\n      }\n\n      gbk_first = 0x00;\n      gbk_second = 0x00;\n      gbk_third = 0x00;\n\n      if (code_point === null) {\n        byte_pointer.offset(-3);\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (gbk_second !== 0x00) {\n      if (inRange(bite, 0x81, 0xFE)) {\n        gbk_third = bite;\n        return null;\n      }\n\n      byte_pointer.offset(-2);\n      gbk_first = 0x00;\n      gbk_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    if (gbk_first !== 0x00) {\n      if (inRange(bite, 0x30, 0x39) && gb18030) {\n        gbk_second = bite;\n        return null;\n      }\n\n      var lead = gbk_first;\n      var pointer = null;\n      gbk_first = 0x00;\n      var offset = bite < 0x7F ? 0x40 : 0x41;\n\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) {\n        pointer = (lead - 0x81) * 190 + (bite - offset);\n      }\n\n      code_point = pointer === null ? null : indexCodePointFor(pointer, indexes['gbk']);\n\n      if (pointer === null) {\n        byte_pointer.offset(-1);\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    if (bite === 0x80) {\n      return 0x20AC;\n    }\n\n    if (inRange(bite, 0x81, 0xFE)) {\n      gbk_first = bite;\n      return null;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {boolean} gb18030 True if decoding gb18030, false otherwise.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction GBKEncoder(gb18030, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['gbk']);\n\n    if (pointer !== null) {\n      var lead = div(pointer, 190) + 0x81;\n      var trail = pointer % 190;\n      var offset = trail < 0x3F ? 0x40 : 0x41;\n      return output_byte_stream.emit(lead, trail + offset);\n    }\n\n    if (pointer === null && !gb18030) {\n      return encoderError(code_point);\n    }\n\n    pointer = indexGB18030PointerFor(code_point);\n    var byte1 = div(div(div(pointer, 10), 126), 10);\n    pointer = pointer - byte1 * 10 * 126 * 10;\n    var byte2 = div(div(pointer, 10), 126);\n    pointer = pointer - byte2 * 10 * 126;\n    var byte3 = div(pointer, 10);\n    var byte4 = pointer - byte3 * 10;\n    return output_byte_stream.emit(byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30);\n  };\n}\n\nname_to_encoding['gbk'].getEncoder = function (options) {\n  return new GBKEncoder(false, options);\n};\n\nname_to_encoding['gbk'].getDecoder = function (options) {\n  return new GBKDecoder(false, options);\n}; // 9.2 gb18030\n\n\nname_to_encoding['gb18030'].getEncoder = function (options) {\n  return new GBKEncoder(true, options);\n};\n\nname_to_encoding['gb18030'].getDecoder = function (options) {\n  return new GBKDecoder(true, options);\n}; // 10.2 hz-gb-2312\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction HZGB2312Decoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {boolean} */\n  hzgb2312 = false,\n\n  /** @type {number} */\n  hzgb2312_lead = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && hzgb2312_lead === 0x00) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && hzgb2312_lead !== 0x00) {\n      hzgb2312_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n\n    if (hzgb2312_lead === 0x7E) {\n      hzgb2312_lead = 0x00;\n\n      if (bite === 0x7B) {\n        hzgb2312 = true;\n        return null;\n      }\n\n      if (bite === 0x7D) {\n        hzgb2312 = false;\n        return null;\n      }\n\n      if (bite === 0x7E) {\n        return 0x007E;\n      }\n\n      if (bite === 0x0A) {\n        return null;\n      }\n\n      byte_pointer.offset(-1);\n      return decoderError(fatal);\n    }\n\n    if (hzgb2312_lead !== 0x00) {\n      var lead = hzgb2312_lead;\n      hzgb2312_lead = 0x00;\n      var code_point = null;\n\n      if (inRange(bite, 0x21, 0x7E)) {\n        code_point = indexCodePointFor((lead - 1) * 190 + (bite + 0x3F), indexes['gbk']);\n      }\n\n      if (bite === 0x0A) {\n        hzgb2312 = false;\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (bite === 0x7E) {\n      hzgb2312_lead = 0x7E;\n      return null;\n    }\n\n    if (hzgb2312) {\n      if (inRange(bite, 0x20, 0x7F)) {\n        hzgb2312_lead = bite;\n        return null;\n      }\n\n      if (bite === 0x0A) {\n        hzgb2312 = false;\n      }\n\n      return decoderError(fatal);\n    }\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction HZGB2312Encoder(options) {\n  var fatal = options.fatal;\n  /** @type {boolean} */\n\n  var hzgb2312 = false;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F) && hzgb2312) {\n      code_point_pointer.offset(-1);\n      hzgb2312 = false;\n      return output_byte_stream.emit(0x7E, 0x7D);\n    }\n\n    if (code_point === 0x007E) {\n      return output_byte_stream.emit(0x7E, 0x7E);\n    }\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    if (!hzgb2312) {\n      code_point_pointer.offset(-1);\n      hzgb2312 = true;\n      return output_byte_stream.emit(0x7E, 0x7B);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['gbk']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead = div(pointer, 190) + 1;\n    var trail = pointer % 190 - 0x3F;\n\n    if (!inRange(lead, 0x21, 0x7E) || !inRange(trail, 0x21, 0x7E)) {\n      return encoderError(code_point);\n    }\n\n    return output_byte_stream.emit(lead, trail);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['hz-gb-2312'].getEncoder = function (options) {\n  return new HZGB2312Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['hz-gb-2312'].getDecoder = function (options) {\n  return new HZGB2312Decoder(options);\n}; //\n// 11. Legacy multi-byte Chinese (traditional) encodings\n//\n// 11.1 big5\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction Big5Decoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  big5_lead = 0x00,\n\n  /** @type {?number} */\n  big5_pending = null;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte steram to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    // NOTE: Hack to support emitting two code points\n    if (big5_pending !== null) {\n      var pending = big5_pending;\n      big5_pending = null;\n      return pending;\n    }\n\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && big5_lead === 0x00) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && big5_lead !== 0x00) {\n      big5_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n\n    if (big5_lead !== 0x00) {\n      var lead = big5_lead;\n      var pointer = null;\n      big5_lead = 0x00;\n      var offset = bite < 0x7F ? 0x40 : 0x62;\n\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) {\n        pointer = (lead - 0x81) * 157 + (bite - offset);\n      }\n\n      if (pointer === 1133) {\n        big5_pending = 0x0304;\n        return 0x00CA;\n      }\n\n      if (pointer === 1135) {\n        big5_pending = 0x030C;\n        return 0x00CA;\n      }\n\n      if (pointer === 1164) {\n        big5_pending = 0x0304;\n        return 0x00EA;\n      }\n\n      if (pointer === 1166) {\n        big5_pending = 0x030C;\n        return 0x00EA;\n      }\n\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, indexes['big5']);\n\n      if (pointer === null) {\n        byte_pointer.offset(-1);\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    if (inRange(bite, 0x81, 0xFE)) {\n      big5_lead = bite;\n      return null;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction Big5Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['big5']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead = div(pointer, 157) + 0x81; //if (lead < 0xA1) {\n    //  return encoderError(code_point);\n    //}\n\n    var trail = pointer % 157;\n    var offset = trail < 0x3F ? 0x40 : 0x62;\n    return output_byte_stream.emit(lead, trail + offset);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['big5'].getEncoder = function (options) {\n  return new Big5Encoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['big5'].getDecoder = function (options) {\n  return new Big5Decoder(options);\n}; //\n// 12. Legacy multi-byte Japanese encodings\n//\n// 12.1 euc.jp\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction EUCJPDecoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  eucjp_first = 0x00,\n\n  /** @type {number} */\n  eucjp_second = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte) {\n      if (eucjp_first === 0x00 && eucjp_second === 0x00) {\n        return EOF_code_point;\n      }\n\n      eucjp_first = 0x00;\n      eucjp_second = 0x00;\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n    var lead, code_point;\n\n    if (eucjp_second !== 0x00) {\n      lead = eucjp_second;\n      eucjp_second = 0x00;\n      code_point = null;\n\n      if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n        code_point = indexCodePointFor((lead - 0xA1) * 94 + bite - 0xA1, indexes['jis0212']);\n      }\n\n      if (!inRange(bite, 0xA1, 0xFE)) {\n        byte_pointer.offset(-1);\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (eucjp_first === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n      eucjp_first = 0x00;\n      return 0xFF61 + bite - 0xA1;\n    }\n\n    if (eucjp_first === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n      eucjp_first = 0x00;\n      eucjp_second = bite;\n      return null;\n    }\n\n    if (eucjp_first !== 0x00) {\n      lead = eucjp_first;\n      eucjp_first = 0x00;\n      code_point = null;\n\n      if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n        code_point = indexCodePointFor((lead - 0xA1) * 94 + bite - 0xA1, indexes['jis0208']);\n      }\n\n      if (!inRange(bite, 0xA1, 0xFE)) {\n        byte_pointer.offset(-1);\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n      eucjp_first = bite;\n      return null;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction EUCJPEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    if (code_point === 0x00A5) {\n      return output_byte_stream.emit(0x5C);\n    }\n\n    if (code_point === 0x203E) {\n      return output_byte_stream.emit(0x7E);\n    }\n\n    if (inRange(code_point, 0xFF61, 0xFF9F)) {\n      return output_byte_stream.emit(0x8E, code_point - 0xFF61 + 0xA1);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['jis0208']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead = div(pointer, 94) + 0xA1;\n    var trail = pointer % 94 + 0xA1;\n    return output_byte_stream.emit(lead, trail);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['euc-jp'].getEncoder = function (options) {\n  return new EUCJPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['euc-jp'].getDecoder = function (options) {\n  return new EUCJPDecoder(options);\n}; // 12.2 iso-2022-jp\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction ISO2022JPDecoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n\n  var state = {\n    ASCII: 0,\n    escape_start: 1,\n    escape_middle: 2,\n    escape_final: 3,\n    lead: 4,\n    trail: 5,\n    Katakana: 6\n  };\n  var\n  /** @type {number} */\n  iso2022jp_state = state.ASCII,\n\n  /** @type {boolean} */\n  iso2022jp_jis0212 = false,\n\n  /** @type {number} */\n  iso2022jp_lead = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite !== EOF_byte) {\n      byte_pointer.offset(1);\n    }\n\n    switch (iso2022jp_state) {\n      default:\n      case state.ASCII:\n        if (bite === 0x1B) {\n          iso2022jp_state = state.escape_start;\n          return null;\n        }\n\n        if (inRange(bite, 0x00, 0x7F)) {\n          return bite;\n        }\n\n        if (bite === EOF_byte) {\n          return EOF_code_point;\n        }\n\n        return decoderError(fatal);\n\n      case state.escape_start:\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_state = state.escape_middle;\n          return null;\n        }\n\n        if (bite !== EOF_byte) {\n          byte_pointer.offset(-1);\n        }\n\n        iso2022jp_state = state.ASCII;\n        return decoderError(fatal);\n\n      case state.escape_middle:\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) {\n          iso2022jp_jis0212 = false;\n          iso2022jp_state = state.lead;\n          return null;\n        }\n\n        if (lead === 0x24 && bite === 0x28) {\n          iso2022jp_state = state.escape_final;\n          return null;\n        }\n\n        if (lead === 0x28 && (bite === 0x42 || bite === 0x4A)) {\n          iso2022jp_state = state.ASCII;\n          return null;\n        }\n\n        if (lead === 0x28 && bite === 0x49) {\n          iso2022jp_state = state.Katakana;\n          return null;\n        }\n\n        if (bite === EOF_byte) {\n          byte_pointer.offset(-1);\n        } else {\n          byte_pointer.offset(-2);\n        }\n\n        iso2022jp_state = state.ASCII;\n        return decoderError(fatal);\n\n      case state.escape_final:\n        if (bite === 0x44) {\n          iso2022jp_jis0212 = true;\n          iso2022jp_state = state.lead;\n          return null;\n        }\n\n        if (bite === EOF_byte) {\n          byte_pointer.offset(-2);\n        } else {\n          byte_pointer.offset(-3);\n        }\n\n        iso2022jp_state = state.ASCII;\n        return decoderError(fatal);\n\n      case state.lead:\n        if (bite === 0x0A) {\n          iso2022jp_state = state.ASCII;\n          return decoderError(fatal, 0x000A);\n        }\n\n        if (bite === 0x1B) {\n          iso2022jp_state = state.escape_start;\n          return null;\n        }\n\n        if (bite === EOF_byte) {\n          return EOF_code_point;\n        }\n\n        iso2022jp_lead = bite;\n        iso2022jp_state = state.trail;\n        return null;\n\n      case state.trail:\n        iso2022jp_state = state.lead;\n\n        if (bite === EOF_byte) {\n          return decoderError(fatal);\n        }\n\n        var code_point = null;\n        var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n        if (inRange(iso2022jp_lead, 0x21, 0x7E) && inRange(bite, 0x21, 0x7E)) {\n          code_point = iso2022jp_jis0212 === false ? indexCodePointFor(pointer, indexes['jis0208']) : indexCodePointFor(pointer, indexes['jis0212']);\n        }\n\n        if (code_point === null) {\n          return decoderError(fatal);\n        }\n\n        return code_point;\n\n      case state.Katakana:\n        if (bite === 0x1B) {\n          iso2022jp_state = state.escape_start;\n          return null;\n        }\n\n        if (inRange(bite, 0x21, 0x5F)) {\n          return 0xFF61 + bite - 0x21;\n        }\n\n        if (bite === EOF_byte) {\n          return EOF_code_point;\n        }\n\n        return decoderError(fatal);\n    }\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction ISO2022JPEncoder(options) {\n  var fatal = options.fatal;\n  /** @enum */\n\n  var state = {\n    ASCII: 0,\n    lead: 1,\n    Katakana: 2\n  };\n  var\n  /** @type {number} */\n  iso2022jp_state = state.ASCII;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if ((inRange(code_point, 0x0000, 0x007F) || code_point === 0x00A5 || code_point === 0x203E) && iso2022jp_state !== state.ASCII) {\n      code_point_pointer.offset(-1);\n      iso2022jp_state = state.ASCII;\n      return output_byte_stream.emit(0x1B, 0x28, 0x42);\n    }\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    if (code_point === 0x00A5) {\n      return output_byte_stream.emit(0x5C);\n    }\n\n    if (code_point === 0x203E) {\n      return output_byte_stream.emit(0x7E);\n    }\n\n    if (inRange(code_point, 0xFF61, 0xFF9F) && iso2022jp_state !== state.Katakana) {\n      code_point_pointer.offset(-1);\n      iso2022jp_state = state.Katakana;\n      return output_byte_stream.emit(0x1B, 0x28, 0x49);\n    }\n\n    if (inRange(code_point, 0xFF61, 0xFF9F)) {\n      return output_byte_stream.emit(code_point - 0xFF61 - 0x21);\n    }\n\n    if (iso2022jp_state !== state.lead) {\n      code_point_pointer.offset(-1);\n      iso2022jp_state = state.lead;\n      return output_byte_stream.emit(0x1B, 0x24, 0x42);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['jis0208']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead = div(pointer, 94) + 0x21;\n    var trail = pointer % 94 + 0x21;\n    return output_byte_stream.emit(lead, trail);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['iso-2022-jp'].getEncoder = function (options) {\n  return new ISO2022JPEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['iso-2022-jp'].getDecoder = function (options) {\n  return new ISO2022JPDecoder(options);\n}; // 12.3 shift_jis\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction ShiftJISDecoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  shiftjis_lead = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && shiftjis_lead === 0x00) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && shiftjis_lead !== 0x00) {\n      shiftjis_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n\n    if (shiftjis_lead !== 0x00) {\n      var lead = shiftjis_lead;\n      shiftjis_lead = 0x00;\n\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) {\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n        var lead_offset = lead < 0xA0 ? 0x81 : 0xC1;\n        var code_point = indexCodePointFor((lead - lead_offset) * 188 + bite - offset, indexes['jis0208']);\n\n        if (code_point === null) {\n          return decoderError(fatal);\n        }\n\n        return code_point;\n      }\n\n      byte_pointer.offset(-1);\n      return decoderError(fatal);\n    }\n\n    if (inRange(bite, 0x00, 0x80)) {\n      return bite;\n    }\n\n    if (inRange(bite, 0xA1, 0xDF)) {\n      return 0xFF61 + bite - 0xA1;\n    }\n\n    if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n      shiftjis_lead = bite;\n      return null;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction ShiftJISEncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x0080)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    if (code_point === 0x00A5) {\n      return output_byte_stream.emit(0x5C);\n    }\n\n    if (code_point === 0x203E) {\n      return output_byte_stream.emit(0x7E);\n    }\n\n    if (inRange(code_point, 0xFF61, 0xFF9F)) {\n      return output_byte_stream.emit(code_point - 0xFF61 + 0xA1);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['jis0208']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead = div(pointer, 188);\n    var lead_offset = lead < 0x1F ? 0x81 : 0xC1;\n    var trail = pointer % 188;\n    var offset = trail < 0x3F ? 0x40 : 0x41;\n    return output_byte_stream.emit(lead + lead_offset, trail + offset);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['shift_jis'].getEncoder = function (options) {\n  return new ShiftJISEncoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['shift_jis'].getDecoder = function (options) {\n  return new ShiftJISDecoder(options);\n}; //\n// 13. Legacy multi-byte Korean encodings\n//\n// 13.1 euc-kr\n\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction EUCKRDecoder(options) {\n  var fatal = options.fatal;\n  var\n  /** @type {number} */\n  euckr_lead = 0x00;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && euckr_lead === 0) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && euckr_lead !== 0) {\n      euckr_lead = 0x00;\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n\n    if (euckr_lead !== 0x00) {\n      var lead = euckr_lead;\n      var pointer = null;\n      euckr_lead = 0x00;\n\n      if (inRange(lead, 0x81, 0xC6)) {\n        var temp = (26 + 26 + 126) * (lead - 0x81);\n\n        if (inRange(bite, 0x41, 0x5A)) {\n          pointer = temp + bite - 0x41;\n        } else if (inRange(bite, 0x61, 0x7A)) {\n          pointer = temp + 26 + bite - 0x61;\n        } else if (inRange(bite, 0x81, 0xFE)) {\n          pointer = temp + 26 + 26 + bite - 0x81;\n        }\n      }\n\n      if (inRange(lead, 0xC7, 0xFD) && inRange(bite, 0xA1, 0xFE)) {\n        pointer = (26 + 26 + 126) * (0xC7 - 0x81) + (lead - 0xC7) * 94 + (bite - 0xA1);\n      }\n\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, indexes['euc-kr']);\n\n      if (pointer === null) {\n        byte_pointer.offset(-1);\n      }\n\n      if (code_point === null) {\n        return decoderError(fatal);\n      }\n\n      return code_point;\n    }\n\n    if (inRange(bite, 0x00, 0x7F)) {\n      return bite;\n    }\n\n    if (inRange(bite, 0x81, 0xFD)) {\n      euckr_lead = bite;\n      return null;\n    }\n\n    return decoderError(fatal);\n  };\n}\n/**\n * @constructor\n * @param {{fatal: boolean}} options\n */\n\n\nfunction EUCKREncoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0x0000, 0x007F)) {\n      return output_byte_stream.emit(code_point);\n    }\n\n    var pointer = indexPointerFor(code_point, indexes['euc-kr']);\n\n    if (pointer === null) {\n      return encoderError(code_point);\n    }\n\n    var lead, trail;\n\n    if (pointer < (26 + 26 + 126) * (0xC7 - 0x81)) {\n      lead = div(pointer, 26 + 26 + 126) + 0x81;\n      trail = pointer % (26 + 26 + 126);\n      var offset = trail < 26 ? 0x41 : trail < 26 + 26 ? 0x47 : 0x4D;\n      return output_byte_stream.emit(lead, trail + offset);\n    }\n\n    pointer = pointer - (26 + 26 + 126) * (0xC7 - 0x81);\n    lead = div(pointer, 94) + 0xC7;\n    trail = pointer % 94 + 0xA1;\n    return output_byte_stream.emit(lead, trail);\n  };\n}\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['euc-kr'].getEncoder = function (options) {\n  return new EUCKREncoder(options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['euc-kr'].getDecoder = function (options) {\n  return new EUCKRDecoder(options);\n}; //\n// 14. Legacy miscellaneous encodings\n//\n// 14.1 replacement\n// Not needed - API throws TypeError\n// 14.2 utf-16\n\n/**\n * @constructor\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction UTF16Decoder(utf16_be, options) {\n  var fatal = options.fatal;\n  var\n  /** @type {?number} */\n  utf16_lead_byte = null,\n\n  /** @type {?number} */\n  utf16_lead_surrogate = null;\n  /**\n   * @param {ByteInputStream} byte_pointer The byte stream to decode.\n   * @return {?number} The next code point decoded, or null if not enough\n   *     data exists in the input stream to decode a complete code point.\n   */\n\n  this.decode = function (byte_pointer) {\n    var bite = byte_pointer.get();\n\n    if (bite === EOF_byte && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n      return EOF_code_point;\n    }\n\n    if (bite === EOF_byte && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n      return decoderError(fatal);\n    }\n\n    byte_pointer.offset(1);\n\n    if (utf16_lead_byte === null) {\n      utf16_lead_byte = bite;\n      return null;\n    }\n\n    var code_point;\n\n    if (utf16_be) {\n      code_point = (utf16_lead_byte << 8) + bite;\n    } else {\n      code_point = (bite << 8) + utf16_lead_byte;\n    }\n\n    utf16_lead_byte = null;\n\n    if (utf16_lead_surrogate !== null) {\n      var lead_surrogate = utf16_lead_surrogate;\n      utf16_lead_surrogate = null;\n\n      if (inRange(code_point, 0xDC00, 0xDFFF)) {\n        return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_point - 0xDC00);\n      }\n\n      byte_pointer.offset(-2);\n      return decoderError(fatal);\n    }\n\n    if (inRange(code_point, 0xD800, 0xDBFF)) {\n      utf16_lead_surrogate = code_point;\n      return null;\n    }\n\n    if (inRange(code_point, 0xDC00, 0xDFFF)) {\n      return decoderError(fatal);\n    }\n\n    return code_point;\n  };\n}\n/**\n * @constructor\n * @param {boolean} utf16_be True if big-endian, false if little-endian.\n * @param {{fatal: boolean}} options\n */\n\n\nfunction UTF16Encoder(utf16_be, options) {\n  var fatal = options.fatal;\n  /**\n   * @param {ByteOutputStream} output_byte_stream Output byte stream.\n   * @param {CodePointInputStream} code_point_pointer Input stream.\n   * @return {number} The last byte emitted.\n   */\n\n  this.encode = function (output_byte_stream, code_point_pointer) {\n    /**\n     * @param {number} code_unit\n     * @return {number} last byte emitted\n     */\n    function convert_to_bytes(code_unit) {\n      var byte1 = code_unit >> 8;\n      var byte2 = code_unit & 0x00FF;\n\n      if (utf16_be) {\n        return output_byte_stream.emit(byte1, byte2);\n      }\n\n      return output_byte_stream.emit(byte2, byte1);\n    }\n\n    var code_point = code_point_pointer.get();\n\n    if (code_point === EOF_code_point) {\n      return EOF_byte;\n    }\n\n    code_point_pointer.offset(1);\n\n    if (inRange(code_point, 0xD800, 0xDFFF)) {\n      encoderError(code_point);\n    }\n\n    if (code_point <= 0xFFFF) {\n      return convert_to_bytes(code_point);\n    }\n\n    var lead = div(code_point - 0x10000, 0x400) + 0xD800;\n    var trail = (code_point - 0x10000) % 0x400 + 0xDC00;\n    convert_to_bytes(lead);\n    return convert_to_bytes(trail);\n  };\n} // 14.3 utf-16be\n\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-16be'].getEncoder = function (options) {\n  return new UTF16Encoder(true, options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-16be'].getDecoder = function (options) {\n  return new UTF16Decoder(true, options);\n}; // 14.4 utf-16le\n\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-16le'].getEncoder = function (options) {\n  return new UTF16Encoder(false, options);\n};\n/** @param {{fatal: boolean}} options */\n\n\nname_to_encoding['utf-16le'].getDecoder = function (options) {\n  return new UTF16Decoder(false, options);\n}; // 14.5 x-user-defined\n// TODO: Implement this encoding.\n// NOTE: currently unused\n\n/**\n * @param {string} label The encoding label.\n * @param {ByteInputStream} input_stream The byte stream to test.\n */\n\n\nfunction detectEncoding(label, input_stream) {\n  if (input_stream.match([0xFF, 0xFE])) {\n    input_stream.offset(2);\n    return 'utf-16le';\n  }\n\n  if (input_stream.match([0xFE, 0xFF])) {\n    input_stream.offset(2);\n    return 'utf-16be';\n  }\n\n  if (input_stream.match([0xEF, 0xBB, 0xBF])) {\n    input_stream.offset(3);\n    return 'utf-8';\n  }\n\n  return label;\n}\n\nexports.TextEncoder = TextEncoder;\nexports.TextDecoder = TextDecoder;\nexports.encodingExists = getEncoding;","map":null,"metadata":{},"sourceType":"script"}