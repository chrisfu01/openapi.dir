{"ast":null,"code":"/**\n * @version    0.1.11\n * @date       2015-02-09\n * @stability  2 - Unstable\n * @author     Lauri Rooden <lauri@rooden.ee>\n * @license    MIT License\n */\n!function (URI) {\n  /**\n   * URI Template\n   * @see http://tools.ietf.org/html/rfc6570\n   */\n  var RESERVED = /[!'()]/g // /[[\\]:\\/!#$&()*+,;='?@]/g\n  ,\n      SEPARATORS = {\n    \"\": \",\",\n    \"+\": \",\",\n    \"#\": \",\",\n    \"?\": \"&\"\n  },\n      escapeRe = /[$-\\/?[-^{|}]/g,\n      expandRe = /\\{([#&+.\\/;?]?)((?:[\\w%.]+(\\*|:\\d+)?,?)+)\\}/g,\n      parseRe = RegExp(expandRe.source + \"|.[^{]*?\", \"g\");\n  /*** EXPAND ***/\n\n  function encodeNormal(val) {\n    return encodeURIComponent(val).replace(RESERVED, escape);\n  }\n\n  function notNull(s) {\n    return s != null;\n  }\n\n  function mapCleanJoin(arr, mapFn, joinStr) {\n    arr = arr.map(mapFn).filter(notNull);\n    return arr.length && arr.join(joinStr);\n  }\n\n  function expand(template, data) {\n    return template.replace(expandRe, function (_, op, vals) {\n      var sep = SEPARATORS[op] || op,\n          named = sep == \";\" || sep == \"&\",\n          enc = op && sep == \",\" ? encodeURI : encodeNormal,\n          out = mapCleanJoin(vals.split(\",\"), function (_name) {\n        var mod = _name.split(/[*:]/),\n            name = mod[0],\n            val = data[name];\n\n        if (val == null) return;\n\n        if (typeof val == \"object\") {\n          mod = name != _name;\n\n          if (Array.isArray(val)) {\n            val = mapCleanJoin(val, enc, mod ? named ? sep + name + \"=\" : sep : \",\");\n          } else {\n            val = mapCleanJoin(Object.keys(val), function (key) {\n              return enc(key) + (mod ? \"=\" : \",\") + enc(val[key]);\n            }, mod && (named || sep == \"/\") ? sep : \",\");\n            if (mod) named = 0;\n          }\n\n          if (!val) return;\n        } else {\n          val = enc(mod[1] ? val.slice(0, mod[1]) : val);\n        }\n\n        return named ? name + (val || sep == \"&\" ? \"=\" + val : val) : val;\n      }, sep);\n      return out || out === \"\" ? op != \"+\" ? op + out : out : \"\";\n    });\n  }\n\n  URI.expand = expand;\n  /**/\n\n  URI.Template = function Template(template) {\n    var self = this;\n    self.template = template //if (!(self instanceof Template)) return new Template(template)\n\n    /*** PARSE ***/\n    , pos = 0, lengths = {}, fnStr = \"\", reStr = \"^\" + template.replace(parseRe, function (_, op, vals) {\n      if (!vals) return escapeRegExp(_);\n      var sep = SEPARATORS[op] || op,\n          named = sep == \";\" || sep == \"&\",\n          reGroup = vals.split(\",\").map(function (_name) {\n        var mod = _name.split(/[*:]/),\n            name = mod[0],\n            re = (lengths[name] || \"(\") + \".*?)\";\n\n        pos++; //console.log(\"KEY\", arguments)\n\n        if (mod[1]) {\n          re = \"((?:%..|.){1,\" + mod[1] + \"})\";\n          lengths[name] = \"(\\\\\" + pos;\n        } //TODO: decodeURIComponent throws an Error on invalid input, add try-catch\n\n\n        fnStr += \"t=($[\" + pos + \"]||'').split('\" + sep + \"').map(decodeURIComponent);\";\n        fnStr += \"o[\\\"\" + name + \"\\\"]=t.length>1?t:t[0];\";\n        return named ? escapeRegExp(name) + \"(?:=\" + re + \")?\" : sep == \"&\" ? escapeRegExp(name + \"=\") + re : re;\n      }).join(escapeRegExp(sep));\n      return op != \"+\" ? escapeRegExp(op) + reGroup : reGroup;\n    }) + \"$\", re = RegExp(reStr), fn = Function(\"$\", \"var t,o={};\" + fnStr + \"return o\");\n\n    self.match = function (uri) {\n      var match = re.exec(uri);\n      return match && fn(match);\n    };\n\n    function escapeRegExp(string) {\n      return string.replace(escapeRe, \"\\\\$&\");\n    }\n    /**/\n\n    /*** EXPAND ***/\n\n\n    self.expand = expand.bind(self, template);\n    /**/\n  }; // `this` is `exports` in NodeJS and `window` in browser.\n\n}(this.URI || (this.URI = {}));","map":null,"metadata":{},"sourceType":"script"}