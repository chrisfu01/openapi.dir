{"ast":null,"code":"import _defineProperty from \"/Users/chrisfu/openapi.portal/ui/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/chrisfu/openapi.portal/ui/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/chrisfu/openapi.portal/ui/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/chrisfu/openapi.portal/ui/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport validator from 'validator';\n\nvar FormValidator =\n/*#__PURE__*/\nfunction () {\n  function FormValidator(validations) {\n    _classCallCheck(this, FormValidator);\n\n    // validations is an array of rules specific to a form\n    this.validations = validations;\n  }\n\n  _createClass(FormValidator, [{\n    key: \"validate\",\n    value: function validate(state) {\n      // start out assuming valid\n      var validation = this.valid(); // for each validation rule\n\n      this.validations.forEach(function (rule) {\n        // if the field isn't already marked invalid by an earlier rule\n        if (!validation[rule.field].isInvalid) {\n          // determine the field value, the method to invoke and\n          // optional args from the rule definition\n          var field_value = state[rule.field].toString();\n          var args = rule.args || [];\n          var validation_method = typeof rule.method === 'string' ? validator[rule.method] : rule.method; // call the validation_method with the current field value\n          // as the first argument, any additional arguments, and the\n          // whole state as a final argument.  If the result doesn't\n          // match the rule.validWhen property, then modify the\n          // validation object for the field and set the isValid\n          // field to false\n\n          if (validation_method.apply(void 0, [field_value].concat(_toConsumableArray(args), [state])) != rule.validWhen) {\n            validation[rule.field] = {\n              isInvalid: true,\n              message: rule.message\n            };\n            validation.isValid = false;\n          }\n        }\n      });\n      return validation;\n    } // create a validation object for a valid form\n\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      var validation = {};\n      this.validations.map(function (rule) {\n        return validation[rule.field] = {\n          isInvalid: false,\n          message: ''\n        };\n      });\n      return _objectSpread({\n        isValid: true\n      }, validation);\n    }\n  }]);\n\n  return FormValidator;\n}();\n\nexport { FormValidator as default };","map":{"version":3,"sources":["/Users/chrisfu/openapi.portal/ui/src/utils/FormValidator.js"],"names":["validator","FormValidator","validations","state","validation","valid","forEach","rule","field","isInvalid","field_value","toString","args","validation_method","method","validWhen","message","isValid","map"],"mappings":";;;;;;;;;AAAA,OAAOA,SAAP,MAAsB,WAAtB;;IAEqBC,a;;;AACjB,yBAAYC,WAAZ,EAAyB;AAAA;;AACrB;AACA,SAAKA,WAAL,GAAmBA,WAAnB;AACH;;;;6BAEQC,K,EAAO;AACZ;AACA,UAAIC,UAAU,GAAG,KAAKC,KAAL,EAAjB,CAFY,CAGZ;;AACA,WAAKH,WAAL,CAAiBI,OAAjB,CAAyB,UAAAC,IAAI,EAAI;AAE7B;AACA,YAAI,CAACH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,CAAuBC,SAA5B,EAAuC;AACnC;AACA;AACA,cAAMC,WAAW,GAAGP,KAAK,CAACI,IAAI,CAACC,KAAN,CAAL,CAAkBG,QAAlB,EAApB;AACA,cAAMC,IAAI,GAAGL,IAAI,CAACK,IAAL,IAAa,EAA1B;AACA,cAAMC,iBAAiB,GAAG,OAAON,IAAI,CAACO,MAAZ,KAAuB,QAAvB,GACtBd,SAAS,CAACO,IAAI,CAACO,MAAN,CADa,GAEtBP,IAAI,CAACO,MAFT,CALmC,CAQnC;AACA;AACA;AACA;AACA;AACA;;AACA,cAAID,iBAAiB,MAAjB,UAAkBH,WAAlB,4BAAkCE,IAAlC,IAAwCT,KAAxC,OAAkDI,IAAI,CAACQ,SAA3D,EAAsE;AAClEX,YAAAA,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AACrBC,cAAAA,SAAS,EAAE,IADU;AAErBO,cAAAA,OAAO,EAAET,IAAI,CAACS;AAFO,aAAzB;AAIAZ,YAAAA,UAAU,CAACa,OAAX,GAAqB,KAArB;AACH;AACJ;AACJ,OAzBD;AA0BA,aAAOb,UAAP;AACH,K,CAED;;;;4BACQ;AACJ,UAAMA,UAAU,GAAG,EAAnB;AAEA,WAAKF,WAAL,CAAiBgB,GAAjB,CAAqB,UAAAX,IAAI;AAAA,eACrBH,UAAU,CAACG,IAAI,CAACC,KAAN,CAAV,GAAyB;AAAEC,UAAAA,SAAS,EAAE,KAAb;AAAoBO,UAAAA,OAAO,EAAE;AAA7B,SADJ;AAAA,OAAzB;AAGA;AAASC,QAAAA,OAAO,EAAE;AAAlB,SAA2Bb,UAA3B;AACH;;;;;;SA/CgBH,a","sourcesContent":["import validator from 'validator';\n\nexport default class FormValidator {\n    constructor(validations) {\n        // validations is an array of rules specific to a form\n        this.validations = validations;\n    }\n\n    validate(state) {\n        // start out assuming valid\n        let validation = this.valid();\n        // for each validation rule\n        this.validations.forEach(rule => {\n\n            // if the field isn't already marked invalid by an earlier rule\n            if (!validation[rule.field].isInvalid) {\n                // determine the field value, the method to invoke and\n                // optional args from the rule definition\n                const field_value = state[rule.field].toString();\n                const args = rule.args || [];\n                const validation_method = typeof rule.method === 'string' ?\n                    validator[rule.method] :\n                    rule.method\n                // call the validation_method with the current field value\n                // as the first argument, any additional arguments, and the\n                // whole state as a final argument.  If the result doesn't\n                // match the rule.validWhen property, then modify the\n                // validation object for the field and set the isValid\n                // field to false\n                if (validation_method(field_value, ...args, state) != rule.validWhen) {\n                    validation[rule.field] = {\n                        isInvalid: true,\n                        message: rule.message\n                    }\n                    validation.isValid = false;\n                }\n            }\n        });\n        return validation;\n    }\n    \n    // create a validation object for a valid form\n    valid() {\n        const validation = {}\n\n        this.validations.map(rule => (\n            validation[rule.field] = { isInvalid: false, message: '' }\n        ));\n        return { isValid: true, ...validation };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}