{"ast":null,"code":"var Decoder = require('../utils').Decoder,\n    decodeText = require('../utils').decodeText;\n\nvar RE_CHARSET = /^charset$/i;\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\n\nfunction UrlEncoded(boy, cfg) {\n  if (!(this instanceof UrlEncoded)) return new UrlEncoded(boy, cfg);\n  var limits = cfg.limits,\n      headers = cfg.headers,\n      parsedConType = cfg.parsedConType;\n  this.boy = boy;\n  this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n  this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;\n  this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n  var charset;\n\n  for (var i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {\n      charset = parsedConType[i][1].toLowerCase();\n      break;\n    }\n  }\n\n  if (charset === undefined) charset = cfg.defCharset || 'utf8';\n  this.decoder = new Decoder();\n  this.charset = charset;\n  this._fields = 0;\n  this._state = 'key';\n  this._checkingBytes = true;\n  this._bytesKey = 0;\n  this._bytesVal = 0;\n  this._key = '';\n  this._val = '';\n  this._keyTrunc = false;\n  this._valTrunc = false;\n  this._hitlimit = false;\n}\n\nUrlEncoded.prototype.write = function (data, cb) {\n  if (this._fields === this.fieldsLimit) {\n    if (!this.boy.hitFieldsLimit) {\n      this.boy.hitFieldsLimit = true;\n      this.boy.emit('fieldsLimit');\n    }\n\n    return cb();\n  }\n\n  var idxeq,\n      idxamp,\n      i,\n      p = 0,\n      len = data.length;\n\n  while (p < len) {\n    if (this._state === 'key') {\n      idxeq = idxamp = undefined;\n\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) ++p;\n\n        if (data[i] === 0x3D\n        /*=*/\n        ) {\n            idxeq = i;\n            break;\n          } else if (data[i] === 0x26\n        /*&*/\n        ) {\n            idxamp = i;\n            break;\n          }\n\n        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n          this._hitLimit = true;\n          break;\n        } else if (this._checkingBytes) ++this._bytesKey;\n      }\n\n      if (idxeq !== undefined) {\n        // key with assignment\n        if (idxeq > p) this._key += this.decoder.write(data.toString('binary', p, idxeq));\n        this._state = 'val';\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._val = '';\n        this._bytesVal = 0;\n        this._valTrunc = false;\n        this.decoder.reset();\n        p = idxeq + 1;\n      } else if (idxamp !== undefined) {\n        // key with no assignment\n        ++this._fields;\n        var key,\n            keyTrunc = this._keyTrunc;\n        if (idxamp > p) key = this._key += this.decoder.write(data.toString('binary', p, idxamp));else key = this._key;\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n\n        if (key.length) {\n          this.boy.emit('field', decodeText(key, 'binary', this.charset), '', keyTrunc, false);\n        }\n\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit) return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) this._key += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n\n        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._keyTrunc = true;\n        }\n      } else {\n        if (p < len) this._key += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    } else {\n      idxamp = undefined;\n\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) ++p;\n\n        if (data[i] === 0x26\n        /*&*/\n        ) {\n            idxamp = i;\n            break;\n          }\n\n        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n          this._hitLimit = true;\n          break;\n        } else if (this._checkingBytes) ++this._bytesVal;\n      }\n\n      if (idxamp !== undefined) {\n        ++this._fields;\n        if (idxamp > p) this._val += this.decoder.write(data.toString('binary', p, idxamp));\n        this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n        this._state = 'key';\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit) return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) this._val += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n\n        if (this._val === '' && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._valTrunc = true;\n        }\n      } else {\n        if (p < len) this._val += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    }\n  }\n\n  cb();\n};\n\nUrlEncoded.prototype.end = function () {\n  if (this.boy._done) return;\n\n  if (this._state === 'key' && this._key.length > 0) {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset), '', this._keyTrunc, false);\n  } else if (this._state === 'val') {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n  }\n\n  this.boy._done = true;\n  this.boy.emit('finish');\n};\n\nmodule.exports = UrlEncoded;","map":null,"metadata":{},"sourceType":"script"}