{"ast":null,"code":"'use strict';\n\nvar each = require('foreach');\n\nmodule.exports = api;\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api(obj, pointer, value) {\n  // .set()\n  if (arguments.length === 3) {\n    return api.set(obj, pointer, value);\n  } // .get()\n\n\n  if (arguments.length === 2) {\n    return api.get(obj, pointer);\n  } // Return a partially applied function on `obj`.\n\n\n  var wrapped = api.bind(api, obj); // Support for oo style\n\n  for (var name in api) {\n    if (api.hasOwnProperty(name)) {\n      wrapped[name] = api[name].bind(wrapped, obj);\n    }\n  }\n\n  return wrapped;\n}\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\n\n\napi.get = function get(obj, pointer) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n  for (var i = 0; i < refTokens.length; ++i) {\n    var tok = refTokens[i];\n\n    if (!(typeof obj == 'object' && tok in obj)) {\n      throw new Error('Invalid reference token: ' + tok);\n    }\n\n    obj = obj[tok];\n  }\n\n  return obj;\n};\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\n\n\napi.set = function set(obj, pointer, value) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n  for (var i = 0; i < refTokens.length - 1; ++i) {\n    var tok = refTokens[i];\n\n    if (tok === '-' && Array.isArray(obj)) {\n      tok = obj.length;\n    }\n\n    nextTok = refTokens[i + 1];\n\n    if (!(tok in obj)) {\n      if (nextTok.match(/^(\\d+|-)$/)) {\n        obj[tok] = [];\n      } else {\n        obj[tok] = {};\n      }\n    }\n\n    obj = obj[tok];\n  }\n\n  if (nextTok === '-' && Array.isArray(obj)) {\n    nextTok = obj.length;\n  }\n\n  obj[nextTok] = value;\n  return this;\n};\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\n\n\napi.remove = function (obj, pointer) {\n  var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n  var finalToken = refTokens[refTokens.length - 1];\n\n  if (finalToken === undefined) {\n    throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n  }\n\n  var parent = api.get(obj, refTokens.slice(0, -1));\n\n  if (Array.isArray(parent)) {\n    var index = +finalToken;\n\n    if (finalToken === '' && isNaN(index)) {\n      throw new Error('Invalid array index: \"' + finalToken + '\"');\n    }\n\n    Array.prototype.splice.call(parent, index, 1);\n  } else {\n    delete parent[finalToken];\n  }\n};\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\n\n\napi.dict = function dict(obj, descend) {\n  var results = {};\n  api.walk(obj, function (value, pointer) {\n    results[pointer] = value;\n  }, descend);\n  return results;\n};\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\n\n\napi.walk = function walk(obj, iterator, descend) {\n  var refTokens = [];\n\n  descend = descend || function (value) {\n    var type = Object.prototype.toString.call(value);\n    return type === '[object Object]' || type === '[object Array]';\n  };\n\n  (function next(cur) {\n    each(cur, function (value, key) {\n      refTokens.push(String(key));\n\n      if (descend(value)) {\n        next(value);\n      } else {\n        iterator(value, api.compile(refTokens));\n      }\n\n      refTokens.pop();\n    });\n  })(obj);\n};\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\n\n\napi.has = function has(obj, pointer) {\n  try {\n    api.get(obj, pointer);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\n\n\napi.escape = function escape(str) {\n  return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\n\n\napi.unescape = function unescape(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\n\n\napi.parse = function parse(pointer) {\n  if (pointer === '') {\n    return [];\n  }\n\n  if (pointer.charAt(0) !== '/') {\n    throw new Error('Invalid JSON pointer: ' + pointer);\n  }\n\n  return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\n\n\napi.compile = function compile(refTokens) {\n  if (refTokens.length === 0) {\n    return '';\n  }\n\n  return '/' + refTokens.map(api.escape).join('/');\n};","map":null,"metadata":{},"sourceType":"script"}